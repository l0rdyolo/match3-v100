{"version":3,"sources":["file:///C:/Users/maide/OneDrive/Documents/GitHub/match3-v100/assets/Scripts/Grid/GravityHandler.ts"],"names":["_decorator","Component","Vec3","GridManager","ccclass","property","GravityHandler","onLoad","applyGravity","grid","getInstance","moved","promises","col","length","row","node","piece","push","moveToPosition","Promise","all","fillEmptySpaces","emptySpaces"],"mappings":";;;;;;;;;;;;;;;;AAASA,MAAAA,U,OAAAA,U;AAAYC,MAAAA,S,OAAAA,S;AAAWC,MAAAA,I,OAAAA,I;;AAEvBC,MAAAA,W,iBAAAA,W;;;;;;;;;OACH;AAAEC,QAAAA,OAAF;AAAWC,QAAAA;AAAX,O,GAAwBL,U;;gCAGjBM,c,WADZF,OAAO,CAAC,gBAAD,C,gBAAR,MACaE,cADb,SACoCL,SADpC,CAC8C;AAC1CM,QAAAA,MAAM,GAAG;AACL,gBAAMA,MAAN;AACH;;AAGiB,cAAZC,YAAY,GAAG;AACrB,gBAAMC,IAAI,GAAG;AAAA;AAAA,0CAAYC,WAAZ,GAA0BD,IAAvC;AACA,cAAIE,KAAK,GAAG,KAAZ;;AAEA,aAAG;AACCA,YAAAA,KAAK,GAAG,KAAR;AACA,gBAAIC,QAAyB,GAAG,EAAhC,CAFD,CAEqC;;AAEpC,iBAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGJ,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAhC,EAAwCD,GAAG,EAA3C,EAA+C;AAC3C,mBAAK,IAAIE,GAAG,GAAGN,IAAI,CAACK,MAAL,GAAa,CAA5B,EAA+BC,GAAG,IAAI,CAAtC,EAAyCA,GAAG,EAA5C,EAAgD;AAC5C,oBAAIA,GAAG,GAAG,CAAN,GAAUN,IAAI,CAACK,MAAL,GAAc,CAA5B,EAA+B;;AAC/B,oBAAIL,IAAI,CAACM,GAAD,CAAJ,CAAUF,GAAV,EAAeG,IAAf,KAAwB,IAAxB,IAAgCP,IAAI,CAACM,GAAG,GAAG,CAAP,CAAJ,CAAcF,GAAd,EAAmBG,IAAnB,KAA4B,IAAhE,EAAsE;AAClEP,kBAAAA,IAAI,CAACM,GAAD,CAAJ,CAAUF,GAAV,EAAeG,IAAf,GAAsBP,IAAI,CAACM,GAAG,GAAG,CAAP,CAAJ,CAAcF,GAAd,EAAmBG,IAAzC;AACAP,kBAAAA,IAAI,CAACM,GAAG,GAAG,CAAP,CAAJ,CAAcF,GAAd,EAAmBG,IAAnB,GAA0B,IAA1B;AAEA,wBAAMC,KAAK,GAAGR,IAAI,CAACM,GAAD,CAAJ,CAAUF,GAAV,CAAd;AACAD,kBAAAA,QAAQ,CAACM,IAAT,CAAcD,KAAK,CAACE,cAAN,CAAqB,IAAIjB,IAAJ,CAASW,GAAT,EAAcE,GAAd,EAAmB,CAAnB,CAArB,CAAd,EALkE,CAKN;;AAC5DJ,kBAAAA,KAAK,GAAG,IAAR;AACH;AACJ;AACJ;;AAED,kBAAMS,OAAO,CAACC,GAAR,CAAYT,QAAZ,CAAN,CAlBD,CAkB8B;AAEhC,WApBD,QAoBSD,KApBT,EAJqB,CA0BrB;AACA;;AACH;;AAKWW,QAAAA,eAAe,GAAG;AACtB,gBAAMb,IAAI,GAAG;AAAA;AAAA,0CAAYC,WAAZ,GAA0BD,IAAvC;;AACA,eAAK,IAAII,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGJ,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAhC,EAAwCD,GAAG,EAA3C,EAA+C;AAC3C,gBAAIU,WAAW,GAAG,CAAlB;;AACA,iBAAK,IAAIR,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGN,IAAI,CAACK,MAA7B,EAAqCC,GAAG,EAAxC,EAA4C;AACxC,kBAAIN,IAAI,CAACM,GAAD,CAAJ,CAAUF,GAAV,EAAeG,IAAf,KAAwB,IAA5B,EAAkC;AAC9BO,gBAAAA,WAAW;AACd;AACJ,aAN0C,CAQ3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACH;AACJ,SA1DyC,CA4D1C;AACA;AACA;AACA;;;AA/D0C,O","sourcesContent":["import { _decorator, Component, Vec3 } from \"cc\";\nimport { SingletonComponent } from \"../SingletonComponent\";\nimport { GridManager } from \"./GridManager\";\nconst { ccclass, property } = _decorator;\n\n@ccclass('GravityHandler')\nexport class GravityHandler extends Component {\n    onLoad() {\n        super.onLoad();\n    }\n\n\n    async applyGravity() {\n    const grid = GridManager.getInstance().grid;\n    let moved = false;\n\n    do {\n        moved = false;\n        let promises: Promise<void>[] = []; // Tüm asenkron hareketleri toplamak için bir array\n\n        for (let col = 0; col < grid[0].length; col++) {\n            for (let row = grid.length -1; row >= 0; row--) {\n                if (row + 1 > grid.length - 1) continue;\n                if (grid[row][col].node === null && grid[row + 1][col].node !== null) {\n                    grid[row][col].node = grid[row + 1][col].node;\n                    grid[row + 1][col].node = null;\n                    \n                    const piece = grid[row][col];\n                    promises.push(piece.moveToPosition(new Vec3(col, row, 0))); // Parça hareketini asenkron olarak ekle\n                    moved = true;\n                }\n            }\n        }\n\n        await Promise.all(promises); // Tüm hareketlerin tamamlanmasını bekle\n\n    } while (moved);\n\n    // Boş alanları dolduracak başka işlemler buraya eklenebilir\n    // await this.fillEmptySpaces();\n}\n\n\n\n\n    private fillEmptySpaces() {\n        const grid = GridManager.getInstance().grid;\n        for (let col = 0; col < grid[0].length; col++) {\n            let emptySpaces = 0;\n            for (let row = 0; row < grid.length; row++) {\n                if (grid[row][col].node === null) {\n                    emptySpaces++;\n                }\n            }\n            \n            // // Boş alanları yeni parçalarla doldur\n            // for (let i = 0; i < emptySpaces; i++) {\n            //     const newPiece = this.createNewPiece();\n            //     const row = emptySpaces - i - 1;\n            //     grid[row][col].node = newPiece;\n            //     const pieceComponent = newPiece.getComponent(Piece);\n            //     pieceComponent.moveToPosition(new Vec3(col, row, 0));\n            // }\n        }\n    }\n\n    // private createNewPiece(): Node {\n    //     // Yeni bir parça oluştur ve döndür\n    //     // Bu metodu kendi oyununuza göre uyarlamanız gerekecek\n    // }\n}"]}