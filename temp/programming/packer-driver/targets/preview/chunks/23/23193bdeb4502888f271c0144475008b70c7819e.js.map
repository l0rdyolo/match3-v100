{"version":3,"sources":["file:///C:/Users/maide/OneDrive/Documents/GitHub/match3-v100/assets/Scripts/SooLib/Util/Node.ts"],"names":["findAll","startNode","componentClass","name","results","search","node","component","getComponent","push","children","forEach","childNode","find","result","SooLib"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAsCW,iBAASA,OAAT,CAAsCC,SAAtC,EAAuDC,cAAvD,EAAoFC,IAApF,EAAwG;AAC3G,cAAIC,OAAY,GAAG,EAAnB;;AAEA,mBAASC,MAAT,CAAgBC,IAAhB,EAA4B;AACxB,gBAAI,CAACH,IAAD,IAASG,IAAI,CAACH,IAAL,KAAcA,IAA3B,EAAiC;AAC7B,kBAAII,SAAmB,GAAGD,IAAI,CAACE,YAAL,CAAkBN,cAAlB,CAA1B;;AACA,kBAAIK,SAAJ,EAAe;AACXH,gBAAAA,OAAO,CAACK,IAAR,CAAaF,SAAb;AACH;AACJ;;AAEDD,YAAAA,IAAI,CAACI,QAAL,CAAcC,OAAd,CAAsBC,SAAS,IAAI;AAC/BP,cAAAA,MAAM,CAACO,SAAD,CAAN;AACH,aAFD;AAGH;;AAEDP,UAAAA,MAAM,CAACJ,SAAD,CAAN;AACA,iBAAOG,OAAP;AACH;;;;AA+BM,iBAASS,IAAT,CAAmCZ,SAAnC,EAAoDC,cAApD,EAAiFC,IAAjF,EAA0G;AAC7G,mBAASE,MAAT,CAAgBC,IAAhB,EAAsC;AAClC,gBAAI,CAACH,IAAD,IAASG,IAAI,CAACH,IAAL,KAAcA,IAA3B,EAAiC;AAC7B,kBAAII,SAAmB,GAAGD,IAAI,CAACE,YAAL,CAAkBN,cAAlB,CAA1B;;AACA,kBAAIK,SAAJ,EAAe;AACX,uBAAOA,SAAP;AACH;AACJ;;AAED,iBAAK,IAAIK,SAAT,IAAsBN,IAAI,CAACI,QAA3B,EAAqC;AACjC,kBAAII,MAAM,GAAGT,MAAM,CAACO,SAAD,CAAnB;;AACA,kBAAIE,MAAM,KAAK,IAAf,EAAqB;AACjB,uBAAOA,MAAP;AACH;AACJ;;AAED,mBAAO,IAAP;AACH;;AAED,iBAAOT,MAAM,CAACJ,SAAD,CAAb;AACH;;;SAhGYc,M,sBAAAA,M","sourcesContent":["/********************************************************************************\n                           _____             __    _ __  \n                          / ___/____  ____  / /   (_) /_ \n                          \\__ \\/ __ \\/ __ \\/ /   / / __ \\\n                         ___/ / /_/ / /_/ / /___/ / /_/ /\n                        /____/\\____/\\____/_____/_/_.___/ \n                                 \n********************************************************************************/\n\nimport { _decorator, Component, Node } from 'cc';\n\nexport namespace SooLib {\n    /**\n     * Recursively searches for all components of a specific type starting from\n     * a given node. Optionally, can also match the node's name.\n     * \n     * @template T The component type to search for, extending cc.Component.\n     * \n     * @param {Node} startNode The node to start the search from. The function\n     * will search this node and all of its descendants.\n     *\n     * @param {new() => T} componentClass The class (constructor function) of the\n     * component to search for.\n     *\n     * @param {string} [name] Optional. The name of the node(s) to match. If\n     * provided, only nodes with this name will be considered in the search.\n     * \n     * @returns {T[]} An array of components of the specified type. If no components\n     * are found, the array will be empty.\n     * \n     * @example\n     * // Assuming MyComponent is a class extending cc.Component and you want to\n     * // find all instances starting from the rootNode.\n     * const components = findAll(rootNode, MyComponent);\n     * \n     * // To find all MyComponent instances with a specific node name:\n     * const namedComponents = findAll(rootNode, MyComponent, 'specificNodeName');\n     */\n    export function findAll<T extends Component>(startNode: Node, componentClass: new () => T, name?: string): T[] {\n        let results: T[] = [];\n\n        function search(node: Node) {\n            if (!name || node.name === name) {\n                let component: T | null = node.getComponent(componentClass);\n                if (component) {\n                    results.push(component);\n                }\n            }\n\n            node.children.forEach(childNode => {\n                search(childNode);\n            });\n        }\n\n        search(startNode);\n        return results;\n    }\n\n    /**\n     * Recursively searches for the first component of a specific type starting\n     * from a given node. Optionally, can also match the node's name.\n     * \n     * This function is similar to `findAll`, but it stops and returns at the\n     * first match, making it more efficient if you only need one instance.\n     * \n     * @template T The component type to search for, extending cc.Component.\n     * \n     * @param {Node} startNode The node to start the search from. The function\n     * will search this node and all of its descendants.\n     *\n     * @param {new() => T} componentClass The class (constructor function) of the\n     * component to search for.\n     *\n     * @param {string} [name] Optional. The name of the node to match. If provided,\n     * only nodes with this name will be considered in the search.\n     * \n     * @returns {T | null} The first component of the specified type found, or null\n     * if no such component is found.\n     * \n     * @example\n     * // Assuming MyComponent is a class extending cc.Component and you want to\n     * // find the first instance starting from the rootNode.\n     * const component = find(rootNode, MyComponent);\n     * \n     * // To find the first MyComponent instance with a specific node name:\n     * const namedComponent = find(rootNode, MyComponent, 'specificNodeName');\n     */\n    export function find<T extends Component>(startNode: Node, componentClass: new () => T, name?: string): T | null {\n        function search(node: Node): T | null {\n            if (!name || node.name === name) {\n                let component: T | null = node.getComponent(componentClass);\n                if (component) {\n                    return component;\n                }\n            }\n\n            for (let childNode of node.children) {\n                let result = search(childNode);\n                if (result !== null) {\n                    return result;\n                }\n            }\n\n            return null;\n        }\n\n        return search(startNode);\n    }\n}\n"]}