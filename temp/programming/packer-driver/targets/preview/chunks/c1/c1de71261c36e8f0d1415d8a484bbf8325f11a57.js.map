{"version":3,"sources":["file:///C:/Users/maide/OneDrive/Documents/GitHub/match3-v100/assets/Scripts/Grid/GravityHandler.ts"],"names":["_decorator","Component","tween","Vec3","GridManager","GameGlobal","ccclass","property","GravityHandler","applyGravity","matches","columnPieceCount","Map","piece","col","has","set","get","emptySpaces","applyGravityForSingleColumn","grid","getInstance","row","length","node","console","log","newRow","movePiece","newY","PIECE_CONTENT_SIZE","PIECE_OFFSET","Promise","resolve","to","position","x","call","start"],"mappings":"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","sourcesContent":["import { _decorator, Component, Node, tween, Vec3 } from 'cc';\nimport { Piece } from '../Piece/Piece';\nimport { GridManager } from '../Grid/GridManager';\nimport { GameGlobal } from '../Game/GameGlobal';\nconst { ccclass, property } = _decorator;\n\n@ccclass('GravityHandler')\nexport class GravityHandler extends Component {\n\n\n\n    async applyGravity(matches: Piece[]) {\n        const columnPieceCount = new Map<number, number>(); // Her sütundaki boşlukları tutan bir harita\n\n        // Sütunlardaki boşlukları hesapla\n        for (const piece of matches) {\n            const col = piece.col;\n            if (columnPieceCount.has(col)) {\n                columnPieceCount.set(col, columnPieceCount.get(col) + 1);\n            } else {\n                columnPieceCount.set(col, 1);\n            }\n        }\n\n        // Her sütun için gravity uygula\n        for (const [col, emptySpaces] of columnPieceCount) {\n            await this.applyGravityForSingleColumn(col, emptySpaces);\n        }\n    }\n\n    async applyGravityForSingleColumn(col: number, emptySpaces: number) {\n        const grid = GridManager.getInstance().grid;\n    \n        for (let row = grid.length - 1; row >= 0; row--) {\n            const piece = grid[row][col];\n            \n            if (!piece || piece.node === null) continue;  // Eğer hücre boşsa, geç\n    \n            // Eşleşmenin üzerinde kalan parçaları kontrol et\n            if (row < grid.length - emptySpaces) {\n                console.log(`Row: ${row}, Column: ${col}, Piece: `, piece);\n            }\n    \n            const newRow = row + emptySpaces;\n    \n            if (newRow < grid.length) {\n                grid[newRow][col] = piece;\n                piece.row = newRow;\n                \n                await this.movePiece(piece, newRow, col);\n    \n                grid[row][col] = null;\n            }\n        }\n    }\n    \n\n    movePiece(piece: Piece, newRow: number, col: number): Promise<void> {\n        const newY = newRow * (GameGlobal.PIECE_CONTENT_SIZE + GameGlobal.PIECE_OFFSET);\n\n        return new Promise<void>((resolve) => {\n            tween(piece.node)\n                .to(0.3, { position: new Vec3(piece.node.position.x, newY, 0) })\n                .call(() => resolve())\n                .start();\n        });\n    }\n}\n"]}