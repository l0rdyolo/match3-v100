{"version":3,"sources":["file:///C:/Users/maide/OneDrive/Documents/GitHub/match3-v100/assets/Scripts/Match/MatchChecker.ts"],"names":["MatchChecker","HorizontalMatchStrategy","VerticalMatchStrategy","constructor","matchStrategies","push","checkForMatches","pieceA","pieceB","grid","matchedPieces","strategy","matches","checkMatch","length","concat","checkForMatchesAfterGravity","row","col","isEmpty","isMatched","Promise","all","map","piece","matched"],"mappings":";;;8EAMaA,Y;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AALJC,MAAAA,uB,iBAAAA,uB;;AAEAC,MAAAA,qB,iBAAAA,qB;;;;;;;8BAGIF,Y,GAAN,MAAMA,YAAN,CAAmB;AAGxBG,QAAAA,WAAW,GAAG;AAAA,eAFNC,eAEM,GAF6B,EAE7B;AACZ,eAAKA,eAAL,CAAqBC,IAArB,CAA0B;AAAA;AAAA,mEAA1B;AACA,eAAKD,eAAL,CAAqBC,IAArB,CAA0B;AAAA;AAAA,+DAA1B;AACD,SANuB,CAOxB;;;AAEaC,QAAAA,eAAe,CAC1BC,MAD0B,EAE1BC,MAF0B,EAG1BC,IAH0B,EAIR;AAAA;;AAAA;AAClB,gBAAIC,aAAsB,GAAG,EAA7B;;AAEA,iBAAK,IAAMC,QAAX,IAAuB,KAAI,CAACP,eAA5B,EAA6C;AAC3C,kBAAMQ,OAAO,GAAGD,QAAQ,CAACE,UAAT,CAAoBN,MAApB,EAA4BC,MAA5B,EAAoCC,IAApC,CAAhB;;AACA,kBAAIG,OAAO,CAACE,MAAR,IAAkB,CAAtB,EAAyB;AACvBJ,gBAAAA,aAAa,GAAGA,aAAa,CAACK,MAAd,CAAqBH,OAArB,CAAhB;AACD;AACF;;AACD,mBAAOF,aAAP;AATkB;AAUnB,SAvBuB,CAyBxB;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AACaM,QAAAA,2BAA2B,CAACP,IAAD,EAAqC;AAAA;;AAAA;AAC3E,gBAAIC,aAAsB,GAAG,EAA7B;;AACA,iBAAK,IAAIO,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGR,IAAI,CAACK,MAA7B,EAAqCG,GAAG,EAAxC,EAA4C;AAC1C,mBAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGT,IAAI,CAACQ,GAAD,CAAJ,CAAUH,MAAlC,EAA0CI,GAAG,EAA7C,EAAiD;AAC/C,oBAAMX,MAAM,GAAGE,IAAI,CAACQ,GAAD,CAAJ,CAAUC,GAAV,CAAf;AACA,oBAAMV,MAAM,GAAGC,IAAI,CAACQ,GAAD,CAAJ,CAAUC,GAAV,CAAf;;AAEA,oBACE,CAACX,MAAM,CAACY,OAAR,IACA,CAACZ,MAAM,CAACa,SADR,IAEA,CAACZ,MAAM,CAACW,OAFR,IAGA,CAACX,MAAM,CAACY,SAJV,EAKE;AACA,uBAAK,IAAMT,QAAX,IAAuB,MAAI,CAACP,eAA5B,EAA6C;AAC3C,wBAAMQ,OAAO,GAAGD,QAAQ,CAACE,UAAT,CAAoBN,MAApB,EAA4BC,MAA5B,EAAoCC,IAApC,CAAhB;;AACA,wBAAIG,OAAO,CAACE,MAAR,IAAkB,CAAtB,EAAyB;AACvBJ,sBAAAA,aAAa,GAAGA,aAAa,CAACK,MAAd,CAAqBH,OAArB,CAAhB;AACD;AACF;AACF;AACF;AACF;;AACD,gBAAIF,aAAa,CAACI,MAAd,GAAuB,CAA3B,EAA8B;AACxB,oBAAMO,OAAO,CAACC,GAAR,CAAYZ,aAAa,CAACa,GAAd,CAAkBC,KAAK,IAAIA,KAAK,CAACC,OAAN,EAA3B,CAAZ,CAAN;AACA,qBAAO,IAAP;AACH;;AACH,mBAAO,KAAP;AA1B2E;AA2B5E;;AAhFuB,O","sourcesContent":["import { Piece } from \"../Piece/Piece\";\r\nimport { HorizontalMatchStrategy } from \"./MatchStrategies/HorizontalMatchStrategy\";\r\nimport { MatchStrategy } from \"./MatchStrategies/IMatchStrategy\";\r\nimport { VerticalMatchStrategy } from \"./MatchStrategies/VerticalMatchStrategy\";\r\nimport { GridManager } from \"../Grid/GridManager\";\r\n\r\nexport class MatchChecker {\r\n  private matchStrategies: MatchStrategy[] = [];\r\n\r\n  constructor() {\r\n    this.matchStrategies.push(new HorizontalMatchStrategy());\r\n    this.matchStrategies.push(new VerticalMatchStrategy());\r\n  }\r\n  //! IDEA - 3 : stategyler birbirin tekralrayan kodlar içeriyor. düzenlenmeli\r\n\r\n  public async checkForMatches(\r\n    pieceA: Piece,\r\n    pieceB: Piece,\r\n    grid: Piece[][]\r\n  ): Promise<Piece[]> {\r\n    let matchedPieces: Piece[] = [];\r\n\r\n    for (const strategy of this.matchStrategies) {\r\n      const matches = strategy.checkMatch(pieceA, pieceB, grid);\r\n      if (matches.length >= 3) {\r\n        matchedPieces = matchedPieces.concat(matches);\r\n      }\r\n    }\r\n    return matchedPieces;\r\n  }\r\n\r\n  // public async checkForMatchesAfterGravity(grid:Piece[][]): Promise<Piece[]> {\r\n  //     let matchedPieces: Piece[] = [];\r\n  //     let matchesAfterGravity: Piece[][] = [];\r\n\r\n  //     for (let row = 0; row < grid.length; row++) {\r\n  //         for (let col = 0; col < grid[row].length; col++) {\r\n  //             const piece = grid[row][col];\r\n  //             if (!piece.isEmpty && !piece.isMatched) {\r\n  //                 console.log(\"allah\");\r\n\r\n  //                 for (const strategy of this.matchStrategies) {\r\n  //                     const matches = strategy.checkMatch(piece, piece , grid);\r\n  //                     if (matches.length >= 3) {\r\n  //                         matchedPieces = matchedPieces.concat(matches);\r\n  //                         matchesAfterGravity.push(matches);\r\n  //                     }\r\n  //                 }\r\n  //             }\r\n  //         }\r\n  //     }\r\n\r\n  //     if (matchedPieces.length > 0) {\r\n  //         await Promise.all(matchedPieces.map(piece => piece.matched()));\r\n  //     }\r\n  //     console.log(\"matchesAfterGravity\",matchesAfterGravity);\r\n  //     return matchedPieces;\r\n\r\n  // }\r\n  public async checkForMatchesAfterGravity(grid: Piece[][]) : Promise<boolean> {\r\n    let matchedPieces: Piece[] = [];\r\n    for (let row = 0; row < grid.length; row++) {\r\n      for (let col = 0; col < grid[row].length; col++) {\r\n        const pieceA = grid[row][col];\r\n        const pieceB = grid[row][col];\r\n\r\n        if (\r\n          !pieceA.isEmpty &&\r\n          !pieceA.isMatched &&\r\n          !pieceB.isEmpty &&\r\n          !pieceB.isMatched\r\n        ) {\r\n          for (const strategy of this.matchStrategies) {\r\n            const matches = strategy.checkMatch(pieceA, pieceB, grid);\r\n            if (matches.length >= 3) {\r\n              matchedPieces = matchedPieces.concat(matches);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (matchedPieces.length > 0) {\r\n          await Promise.all(matchedPieces.map(piece => piece.matched()));\r\n          return true;\r\n      }\r\n    return false;\r\n  }\r\n}\r\n"]}