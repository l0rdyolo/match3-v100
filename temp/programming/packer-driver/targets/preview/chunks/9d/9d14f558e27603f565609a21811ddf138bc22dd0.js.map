{"version":3,"sources":["file:///C:/Users/maide/OneDrive/Documents/GitHub/match3-v100/assets/Scripts/Match/MatchChecker.ts"],"names":["MatchChecker","HorizontalMatchStrategy","VerticalMatchStrategy","constructor","matchStrategies","push","checkForMatches","pieceA","pieceB","grid","matchedPieces","strategy","matches","checkMatch","length","concat","checkForMatchesAfterGravity","matchesMap","Map","row","col","piece","isEmpty","isMatched","forEach","p","matched","key","has","set","console","log"],"mappings":";;;8EAMaA,Y;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AALJC,MAAAA,uB,iBAAAA,uB;;AAEAC,MAAAA,qB,iBAAAA,qB;;;;;;;8BAGIF,Y,GAAN,MAAMA,YAAN,CAAmB;AAGtBG,QAAAA,WAAW,GAAG;AAAA,eAFNC,eAEM,GAF6B,EAE7B;AACV,eAAKA,eAAL,CAAqBC,IAArB,CAA0B;AAAA;AAAA,mEAA1B;AACA,eAAKD,eAAL,CAAqBC,IAArB,CAA0B;AAAA;AAAA,+DAA1B;AACH,SANqB,CAOtB;;;AAEaC,QAAAA,eAAe,CAACC,MAAD,EAAgBC,MAAhB,EAA+BC,IAA/B,EAAiE;AAAA;;AAAA;AACzF,gBAAIC,aAAsB,GAAG,EAA7B;;AAEA,iBAAK,IAAMC,QAAX,IAAuB,KAAI,CAACP,eAA5B,EAA6C;AACzC,kBAAMQ,OAAO,GAAGD,QAAQ,CAACE,UAAT,CAAoBN,MAApB,EAA4BC,MAA5B,EAAqCC,IAArC,CAAhB;;AACA,kBAAIG,OAAO,CAACE,MAAR,IAAkB,CAAtB,EAAyB;AACrBJ,gBAAAA,aAAa,GAAGA,aAAa,CAACK,MAAd,CAAqBH,OAArB,CAAhB;AACH;AACJ;;AACD,mBAAOF,aAAP;AATyF;AAU5F,SAnBqB,CAqBtB;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AACaM,QAAAA,2BAA2B,CAACP,IAAD,EAAiB;AAAA;;AAAA;AACrD,gBAAIQ,UAAgC,GAAG,IAAIC,GAAJ,EAAvC;;AAEA,iBAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGV,IAAI,CAACK,MAA7B,EAAqCK,GAAG,EAAxC,EAA4C;AACxC,mBAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGX,IAAI,CAACU,GAAD,CAAJ,CAAUL,MAAlC,EAA0CM,GAAG,EAA7C,EAAiD;AAC7C,oBAAMC,KAAK,GAAGZ,IAAI,CAACU,GAAD,CAAJ,CAAUC,GAAV,CAAd;;AACA,oBAAI,CAACC,KAAK,CAACC,OAAP,IAAkB,CAACD,KAAK,CAACE,SAA7B,EAAwC;AACpC,uBAAK,IAAMZ,QAAX,IAAuB,MAAI,CAACP,eAA5B,EAA6C;AACzC,wBAAMQ,OAAO,GAAGD,QAAQ,CAACE,UAAT,CAAoBQ,KAApB,EAA2BA,KAA3B,EAAkCZ,IAAlC,CAAhB;;AACA,wBAAIG,OAAO,CAACE,MAAR,IAAkB,CAAtB,EAAyB;AACrBF,sBAAAA,OAAO,CAACY,OAAR,CAAgBC,CAAC,IAAIA,CAAC,CAACC,OAAF,EAArB,EADqB,CACc;;AACnC,0BAAMC,GAAG,GAAMR,GAAN,SAAaC,GAAtB;;AACA,0BAAI,CAACH,UAAU,CAACW,GAAX,CAAeD,GAAf,CAAL,EAA0B;AACtBV,wBAAAA,UAAU,CAACY,GAAX,CAAeF,GAAf,EAAoBf,OAApB;AACH;AACJ;AACJ;AACJ;AACJ;AACJ;;AACDkB,YAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAAyBd,UAAzB;AApBqD;AAuBxD;;AAxEqB,O","sourcesContent":["import { Piece } from \"../Piece/Piece\";\r\nimport { HorizontalMatchStrategy } from \"./MatchStrategies/HorizontalMatchStrategy\";\r\nimport { MatchStrategy } from \"./MatchStrategies/IMatchStrategy\";\r\nimport { VerticalMatchStrategy } from \"./MatchStrategies/VerticalMatchStrategy\";\r\nimport { GridManager } from \"../Grid/GridManager\";\r\n\r\nexport class MatchChecker {\r\n    private matchStrategies: MatchStrategy[] = [];\r\n\r\n    constructor() {\r\n        this.matchStrategies.push(new HorizontalMatchStrategy());\r\n        this.matchStrategies.push(new VerticalMatchStrategy());\r\n    }\r\n    //! IDEA - 3 : stategyler birbirin tekralrayan kodlar içeriyor. düzenlenmeli\r\n\r\n    public async checkForMatches(pieceA: Piece, pieceB: Piece, grid:Piece[][]): Promise<Piece[]> {\r\n        let matchedPieces: Piece[] = [];\r\n        \r\n        for (const strategy of this.matchStrategies) {\r\n            const matches = strategy.checkMatch(pieceA, pieceB , grid);\r\n            if (matches.length >= 3) {\r\n                matchedPieces = matchedPieces.concat(matches);\r\n            }\r\n        }\r\n        return matchedPieces;\r\n    }\r\n\r\n    // public async checkForMatchesAfterGravity(grid:Piece[][]): Promise<Piece[]> {\r\n    //     let matchedPieces: Piece[] = [];\r\n    //     let matchesAfterGravity: Piece[][] = [];\r\n\r\n    //     for (let row = 0; row < grid.length; row++) {\r\n    //         for (let col = 0; col < grid[row].length; col++) {\r\n    //             const piece = grid[row][col];\r\n    //             if (!piece.isEmpty && !piece.isMatched) {   \r\n    //                 console.log(\"allah\");\r\n                    \r\n    //                 for (const strategy of this.matchStrategies) {\r\n    //                     const matches = strategy.checkMatch(piece, piece , grid);\r\n    //                     if (matches.length >= 3) {\r\n    //                         matchedPieces = matchedPieces.concat(matches);\r\n    //                         matchesAfterGravity.push(matches);\r\n    //                     }\r\n    //                 }\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     if (matchedPieces.length > 0) {\r\n    //         await Promise.all(matchedPieces.map(piece => piece.matched()));\r\n    //     }\r\n    //     console.log(\"matchesAfterGravity\",matchesAfterGravity);\r\n    //     return matchedPieces;\r\n\r\n    // }\r\n    public async checkForMatchesAfterGravity(grid:Piece[][]) {\r\n        let matchesMap: Map<string, Piece[]> = new Map();\r\n\r\n        for (let row = 0; row < grid.length; row++) {\r\n            for (let col = 0; col < grid[row].length; col++) {\r\n                const piece = grid[row][col];\r\n                if (!piece.isEmpty && !piece.isMatched) {\r\n                    for (const strategy of this.matchStrategies) {\r\n                        const matches = strategy.checkMatch(piece, piece, grid);\r\n                        if (matches.length >= 3) {\r\n                            matches.forEach(p => p.matched()); // İşaretle\r\n                            const key = `${row}-${col}`;\r\n                            if (!matchesMap.has(key)) {\r\n                                matchesMap.set(key, matches);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        console.log(\"matchesMap\",matchesMap);\r\n        \r\n\r\n    }\r\n\r\n}\r\n"]}